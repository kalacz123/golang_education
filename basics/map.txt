package main

import (
	"fmt"
	"maps"
)

func main() {
	//var mapVariable map[keyType]valueType
	// mapVariable := make(map[keyType]valueType)

	// using a Map literal
	// mapVariable := map[keyType]valueType{
	// 	key1: value1,
	// 	key2: value2,
	// }

	myMap := make(map[string]int)
	fmt.Println(myMap)

	myMap["key1"] = 9
	fmt.Println(myMap)
	myMap["code"] = 8
	fmt.Println(myMap)
	fmt.Println(myMap["key1"])
	fmt.Println(myMap["code2"]) // returns 0 cause of default value. It depends on the type of the value
	myMap["key1"] = 10
	fmt.Println(myMap["key1"])

	delete(myMap, "key1") // delete a key from the map
	fmt.Println(myMap)

	newMap := map[string]int{
		"key1": 10,
		"code": 8,
	}
	fmt.Println(newMap)

	clear(newMap) // clear all the keys from the map
	fmt.Println(newMap)
	myMap["key1"] = 11

	_, ok := myMap["key1"] // if the key is not found, the value is 0 and the ok is false
	fmt.Println(ok)
	if ok {
		fmt.Println("The key is found")
	} else {
		fmt.Println("The key is not found")
	}

	newMap["key1"] = 11
	newMap["code"] = 8

	if maps.Equal(myMap, newMap) {
		fmt.Println(myMap)
		fmt.Println(newMap)
		fmt.Println("The maps are equal")
	} else {
		fmt.Println(myMap)
		fmt.Println(newMap)
		fmt.Println("The maps are not equal")
	}

	for key, value := range newMap {
		fmt.Printf("Key: %s, Value: %d\n", key, value)
	}

	var myMap4 map[string]string

	if myMap4 == nil {
		fmt.Println("The map is nil")
	} else {
		fmt.Println("The map is not nil")
	}

	val := myMap4["key1"]
	fmt.Println(val)

	// myMap4["key1"] = "value1" // panic: assignment to entry in nil map
	// fmt.Println(myMap4)

	myMap4 = make(map[string]string)
	myMap4["key1"] = "value1"
	fmt.Println(myMap4)

	myMap5 := make(map[string]map[string]string) // nested map

	myMap5["map1"] = myMap4
	fmt.Println(myMap5)
}
